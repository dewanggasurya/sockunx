{
  // ------ Back-end ------
  "Swagger Service Documentation": {
    "scope": "go",
    "prefix": ["swagsrv", "swagservice"],
    "body": [
      "// @title ${1:title}",
      "// @version ${2:version}",
      "// @description ${3:description}",
      "// @termsOfService ${4:terms_of_service_url}",
      "",
      "// @contact.name ${5:contact_name}",
      "// @contact.url ${6:contact_url}",
      "// @contact.email ${7:contact_email}",
      "",
      "// @host ${8:host}",
      "// @BasePath ${9:base_path}",
      "",
      "// @securityDefinitions.apikey ${10:token_auth}",
      "// @in header",
      "// @name Authorization",
      "${0}"
    ],
    "description": "Create swagger API documentation based on github.com/swaggo/swag"
  },
  "Swagger API Documentation": {
    "scope": "go",
    "prefix": ["swagapi", "api_doc", "apidoc"],
    "body": [
      "// ${1} handler",
      "// @Summary ${2:api_summary}",
      "// @Description ${2:api_summary}",
      "// @ID ${3:api_unique_slug}",
      "// @Tags ${4:service_name}",
      "// @Security TokenAuth",
      "// @Accept  ${5|json,xml,plain,html,mpfd,x-www-form-urlencoded,json-api,json-stream,octet-stream,png,jpeg,gif|}",
      "// @Produce ${6|json,xml,plain,html,mpfd,x-www-form-urlencoded,json-api,json-stream,octet-stream,png,jpeg,gif|}",
      "// @Param   ${7:req_variable_name} ${8|body,query,path,header,formData|} ${9:req_struct_name} ${10|true,false|} \"${11:Request payload}\"",
      "// @Success ${12:200} {${13|object,string,integer,number,boolean,array|}} ${14|res_struct_name,res_gets_struct_name{data=[]res_struct_name}|} \"${15:Success response}\"",
      "// @Failure ${16:500} {${17|object,string,integer,number,boolean,array|}} ${18|kaos.HTTPError,string,res_error_struct|} \"${19:Error response}\"",
      "// @Router  /${20:api_route} [${21|post,get,delete,put|}]${0}"
    ],
    "description": "Create swagger API documentation based on github.com/swaggo/swag"
  },
  "Swagger API Documentation (Simple)": {
    "scope": "go",
    "prefix": ["swagsimple"],
    "body": [
      "// ${1:func:[Create]} handler",
      "// @Summary ${2:api_summary:[Create new event]}",
      "// @Description ${2:api_summary:[Create new event]}",
      "// @ID aamining-${3:api_unique_slug:[aamining-activity-gets]}",
      "// @Tags ${4:aamining}",
      "// @Security TokenAuth",
      "// @Accept  json",
      "// @Produce json",
      "// @Param   req ${8|body,query|} ${9:req_struct_name} true \"${11:Request payload}\"",
      "// @Success 200 {${14:object}} ${15:res_struct_name} \"${16:Success response}\"",
      "// @Failure 500 {object} kaos.HTTPError \"${19:Error response}\"",
      "// @Router  /aamining/${20:api_route} [${21|post,get,delete,put|}]${0}"
    ],
    "description": "Create swagger API documentation based on github.com/swaggo/swag"
  },
  "Swagger API Param Documentation": {
    "scope": "go",
    "prefix": ["swagpar", "swagreq"],
    "body": [
      "// @Param ${1:req_name} ${2|body,query,path,header,formData|} ${3:req_type} ${4|true,false|} \"${5:req_description}\"${0}"
    ],
    "description": "Create swagger API documentation based on github.com/swaggo/swag"
  },
  "Swagger API Response Success Documentation": {
    "scope": "go",
    "prefix": "swagress",
    "body": [
      "// @Success ${1:200} {${2|string,integer,number,boolean,object|}} ${3:res_type} \"${4:res_description}\"${0}"
    ],
    "description": "Create swagger API documentation based on github.com/swaggo/swag"
  },
  "Swagger API Response Failure Documentation": {
    "scope": "go",
    "prefix": "swagresf",
    "body": [
      "// @Failure ${1:500} {${2|string,integer,number,boolean,object|}} ${3:res_error_type} \"${4:res_error_description}\"${0}"
    ],
    "description": "Create swagger API documentation based on github.com/swaggo/swag"
  },
  "Create API": {
    "scope": "go",
    "prefix": ["api"],
    "body": [
      "${0}",
      "func (o *${1:engine}) ${2:name}(ctx *kaos.Context, ${3:req} *${4:req_type}) (${5:res_type}, error) {",
      "\t// var res ${5:res_type}",
      "\tpanic(\"not implemented yet\")",
      "}"
    ],
    "description": "Create swagger API documentation based on github.com/swaggo/swag"
  },
  "API Call Repo": {
    "scope": "go",
    "prefix": ["callrepo"],
    "body": [
      "h, e := InitReq(ctx, req)",
      "if e != nil {",
      "  return nil, e",
      "}",
      "",
      "if len(req.BaseGetSRequest.Sort) == 0 {",
      "  req.BaseGetSRequest.Sort = append(req.BaseGetSRequest.Sort, \"-created_at\")",
      "}",
      "",
      "param := setBaseParam(dbflex.NewQueryParam(), req.BaseGetSRequest)",
      "filters := []*dbflex.Filter{}",
      "",
      "if len(filters) > 0 {",
      "  param.SetWhere(dbflex.And(filters...))",
      "}",
      "",
      "data, total, e := new(repo.${1:Repo}).${2:RepoFunc}(h, *param)",
      "if e != nil {",
      "  return nil, e",
      "}",
      "",
      "res := new(${3:Response})",
      "res.Data = data",
      "res.Total = total",
      "",
      "return res, nil"
    ],
    "description": "API Call Repo"
  },
  "Repo Func": {
    "scope": "go",
    "prefix": ["repofunc"],
    "body": [
      "// ${1:RepoFunc} ${4:func comment}",
      "func (o *${2:Chart}) ${1:RepoFunc}(h *datahub.Hub, param dbflex.QueryParam) (res ${3:*Result}, total int, e error) {",
      "\t${0}",
      "}"
    ],
    "description": "Repo Func"
  },
  "Repo Func Pipe": {
    "scope": "go",
    "prefix": ["repofuncpipe"],
    "body": [
      "// ${1:RepoFunc} ${4:func comment}",
      "\tfunc (o *${2:Chart}) ${1:RepoFunc}(h *datahub.Hub, param dbflex.QueryParam) (res ${3:*Result}, total int, e error) {",
      "\tpipe := []bson.M{}",
      "\te = helper.Deserialize(fmt.Sprintf(`",
      "\t\t[",
      "\t\t\t\t",
      "\t\t]",
      "\t\t`), &pipe)",
      "\tif e != nil {",
      "\t\treturn",
      "\t}",
      "\t",
      "\tif where := helper.QueryParamWhereToPipe(param); len(where) > 0 {",
      "\t\tpipe = append([]bson.M{{\"\\$match\": where}}, pipe...)",
      "\t}",
      "\t",
      "\tif sort := helper.QueryParamSortToPipe(param); len(sort) > 0 {",
      "\t\tpipe = append(pipe, bson.M{\"\\$sort\": sort})",
      "\t}",
      "\t",
      "\ttotal, e = helper.QueryPipeWithTotal(h, new(model.ScheduleActivity), &data, pipe, param.Skip, param.Take)",
      "\treturn",
      "}"
    ],
    "description": "Repo Func Pipe"
  },
  "Run Command DBFlex": {
    "scope": "go",
    "prefix": ["cmddbflex"],
    "body": [
      "cmd := dbflex.From(new(${1:model.ModelName}).TableName()).Where(${2:dbflex.Eq(\"_id\", ID)}).Update(${3:\"fieldName\"})",
      "if _, e = h.Execute(cmd, ${4:data}); e != nil {",
      "\treturn ${5:e}",
      "}"
    ],
    "description": "Run Command DBFlex"
  },
  "Create struct": {
    "scope": "go",
    "prefix": ["stru", "stu", "nstru", "nstu"],
    "body": [
      "// ${1:name} ${2:description}",
      "type ${1:name} struct {",
      "\t${0}",
      "}"
    ],
    "description": "Create struct"
  },
  "In Query Payload struct": {
    "scope": "go",
    "prefix": ["payload", "structpayload", "reqinquery"],
    "body": [
      "req := struct {",
      "\t${1:Field} ${2:string} `json:\"${3:field}\" form:\"${3:field}\"`${0}",
      "}{}"
    ],
    "description": "Create struct"
  },
  "Add todo for adding authorize access": {
    "scope": "go",
    "prefix": ["auth", "authpls", "authplz"],
    "body": ["// BUG please give authorization checking :( "],
    "description": "Add todo for adding authorize access"
  },
  "Create model": {
    "scope": "go",
    "prefix": ["nmod", "mod", "model"],
    "body": [
      "package model",
      "",
      "// ${1:name} model",
      "type ${1:name} struct {",
      "\tBaseModel `json:\"-\"`",
      "\tID                string `json:\"_id\"`",
      "\t${0}",
      "\tSchema            int    `json:\"schema\"`",
      "\tCreatedBy string    `json:\"created_by\"`",
      "\tCreatedAt time.Time `json:\"created_at\"`",
      "\tUpdatedBy string    `json:\"updated_by\"`",
      "\tUpdatedAt time.Time `json:\"updated_at\"`",
      "}",
      "",
      "// TableName get model table name",
      "func (o *${1:name}) TableName() string {",
      "\treturn \"${2:table_name}\"",
      "}",
      "",
      "// GetID get model id",
      "func (o *${1:name}) GetID(_ dbflex.IConnection) ([]string, []interface{}) {",
      "\treturn []string{\"_id\"}, []interface{}{o.ID}",
      "}",
      "",
      "// SetID set model  id",
      "func (o *${1:name}) SetID(keys ...interface{}) {",
      "\tif len(keys) > 0 {",
      "\t\to.ID = keys[0].(string)",
      "\t}",
      "}",
      "",
      "// Index create model index or compound index",
      "func (o *${1:name}) Index() [][]Index {",
      "\treturn [][]Index{}",
      "}",
      "",
      "// SchemaVersion version of schema",
      "func (o *${1:name}) SchemaVersion() int {",
      "\treturn 1",
      "}",
      "",
      "// PreSave orm model action pre save",
      "func (o *${1:name}) PreSave(c dbflex.IConnection) error {",
      "\tnow := time.Now()",
      "",
      "\tif e := o.Recent(c); e != nil {",
      "\t\treturn e",
      "\t}",
      "",
      "\tif o.Schema == 0 {",
      "\t\to.Schema = o.SchemaVersion()",
      "\t}",
      "",
      "\tif o.ID == \"\" {",
      "\t\to.ID = helper.GenerateID()",
      "\t}",
      "",
      "\tif o.CreatedAt.IsZero() {",
      "\t\to.CreatedAt = now",
      "\t\to.UpdatedAt = now",
      "\t}",
      "\to.UpdatedAt = now",
      "",
      "\treturn nil",
      "}",
      "",
      "// PostSave orm model action post save",
      "func (o *${1:name}) PostSave(c dbflex.IConnection) error {",
      "\to.CleanAsset(c)",
      "\treturn nil",
      "}",
      ""
    ],
    "description": "Create model"
  },
  "Create model reference": {
    "scope": "go",
    "prefix": ["ref", "refmodel", "modelref"],
    "body": [
      "// Ref${1:Model} embedded from ${1:Model}",
      "type Ref${1:Model} struct {",
      "\tID   string `json:\"_id\"`",
      "\tName string `json:\"name\"`",
      "\t${0}",
      "}"
    ],
    "description": "Create model reference"
  },
  "Sort Model Func": {
    "scope": "go",
    "prefix": ["sortmodelfunc", "modelsortfunc", "funcsortmodel"],
    "body": [
      "// SortDBFlex default sort dbflex",
      "func (o *${1:Model}) SortDBFlex() []string {",
      "\treturn []string{\"${2:fieldName}\"}",
      "}",
      "",
      "// SortQuery default sort dbflex",
      "func (o *${1:Model}) SortQuery() string {",
      "\treturn fmt.Sprintf(`{\"\\$sort\":{\"${2:fieldName}\":1}}`)",
      "}"
    ],
    "description": "Sort Model Func"
  },
  "Transaction defer function": {
    "scope": "go",
    "prefix": ["defertx", "deftx", "txdefer", "txdef"],
    "body": [
      "defer func() {",
      "\tif e != nil {",
      "\t\terr := tx.Rollback()",
      "\t\tif err != nil {",
      "\t\t\tctx.Log().Error(err.Error())",
      "\t\t}",
      "",
      "\t} else {",
      "\t\terr := tx.Commit()",
      "\t\tif err != nil {",
      "\t\t\tctx.Log().Error(err.Error())",
      "\t\t}",
      "\t}",
      "}()"
    ],
    "description": "Transaction defer function"
  },
  "Transaction function": {
    "scope": "go",
    "prefix": ["txfunc"],
    "body": [
      "e = helper.Tx(h, func(tx *datahub.Hub) error {",
      "\t${0:// do something}",
      "\t",
      "\treturn nil",
      "})",
      "if e != nil {",
      "\treturn nil, e",
      "}"
    ],
    "description": "Transaction function"
  },
  "Transaction function with Asset": {
    "scope": "go",
    "prefix": ["txassetfunc"],
    "body": [
      "asset := new(model.Asset)",
      "e = helper.TxAsset(ctx, func(tx *datahub.Hub) (e error) {",
      "\t${0:// do something}",
      "\t",
      "\tif len(req.AssetFieldParam) > 0 {",
      "\t\tif e := assetWriteBase64Embed(ctx, asset, fmt.Sprintf(\"%s_PREFIX\", object.ID), req.AssetFieldParam, \"TAG\"); e != nil {",
      "\t\t\treturn e",
      "\t\t}",
      "\t\tobject.AssetField = asset.ID",
      "\t}",
      "\t",
      "\treturn nil",
      "}, asset)",
      "if e != nil {",
      "\treturn nil, e",
      "}"
    ],
    "description": "Transaction function with Asset"
  },
  "Toolkit JSON String Indent": {
    "scope": "go",
    "prefix": ["json", "jsonstring"],
    "body": ["toolkit.JsonStringIndent(${1:object}, \"\\t\")${0}"],
    "description": "Toolkit JSON String Indent"
  },
  "Print JSON": {
    "scope": "go",
    "prefix": ["printjson"],
    "body": [
      "fmt.Printf(\"${1:object}: %v\\n\", toolkit.JsonStringIndent(${1:object}, \"\\t\"))${0}"
    ],
    "description": "Print JSON"
  },
  "Workspace playground main.go": {
    "scope": "go",
    "prefix": ["play", "goplay"],
    "body": [
      "package main",
      "import (",
      "\t\"flag\"",
      "\t\"os\"",
      "\t\"time\"",
      "\t\"git.kanosolution.net/kano/appkit\"",
      "\t\"git.kanosolution.net/kano/app/internal/helper\"",
      "\t\"git.kanosolution.net/kano/app/internal/model\"",
      "\t\"git.kanosolution.net/kano/kaos\"",
      "\t\"github.com/kanoteknologi/knats\"",
      "\t\"github.com/ariefdarmawan/byter\"",
      "\t_ \"github.com/ariefdarmawan/flexmgo\"",
      "\t\"github.com/ariefdarmawan/kconfigurator\"",
      ")",
      "var (",
      "\terr error",
      "\ts   *kaos.Service",
      "\tappConfig = new(kconfigurator.AppConfig)",
      "\tnats      = flag.String(\"n\", \"nats://localhost:4222\", \"address of NATS server\")",
      "\tsecret    = flag.String(\"key\", \"aamining\", \"key-secret for msvc\")",
      "\tversion   = \"v1\"",
      "\tlog       = appkit.LogWithPrefix(\"playground\")",
      ")",
      "func main() {",
      "\tflag.Parse()",
      "\t// config",
      "\tev := knats.NewEventHub(*nats, byter.NewByter(\"\")).SetSignature(*secret).SetSecret(*secret)",
      "\tdefer ev.Close()",
      "\tappConfig, e := kconfigurator.GetConfigFromEventHub(ev, \"/v1/config/get\")",
      "\tif e != nil {",
      "\t\tlog.Errorf(\"config error. %s\", e.Error())",
      "\t\tos.Exit(1)",
      "\t}",
      "\tlog.Infof(\"successfully reading config from NATS\")",
      "\th, err := kconfigurator.MakeHub(appConfig, \"default\")",
      "\tif err != nil {",
      "\t\tlog.Errorf(\"fail to connect to db. %s\", err.Error())",
      "\t\tos.Exit(1)",
      "\t}",
      "\th.SetAutoReleaseDuration(0 * time.Second)",
      "\th.SetAutoCloseDuration(5 * time.Second)",
      "\tdefer h.Close()",
      "\tbasePath := helper.URLJoin(version, \"playground\")",
      "\ts := kaos.NewService().",
      "\t\tSetLogger(log).",
      "\t\tSetBasePoint(basePath).",
      "\t\tRegisterEventHub(ev, \"default\", appConfig.EventServer.Group).",
      "\t\tRegisterDataHub(h, \"default\")",
      "\tmodel.SetService(s)",
      "\t// Do Something here",
      "\t${0}",
      "}"
    ],
    "description": "Workspace playground main.go"
  },
  "Workspace Playground Func": {
    "scope": "go",
    "prefix": ["playfunc"],
    "body": [
      "// ${1:FuncName} tester",
      "func ${1:FuncName}(h *datahub.Hub, evHub kaos.EventHub, db *mongo.Database${2:, casb *rbac.CasbinRBAC}) error {",
      "\t${0}",
      "\treturn nil",
      "}"
    ],
    "description": "Workspace Playground Func"
  },
  "Init Request": {
    "scope": "go",
    "prefix": ["initreq", "req"],
    "body": [
      "h, e := InitReq(ctx, req)",
      "if e != nil {",
      "\treturn nil, e",
      "}"
    ],
    "description": "Init Request"
  },
  "Init Request with Auth": {
    "scope": "go",
    "prefix": ["initreqauth", "reqauth"],
    "body": [
      "account, h, e := InitReqWithAuth(ctx, req)",
      "if e != nil {",
      "\treturn nil, e",
      "}"
    ],
    "description": "Init Request with Auth"
  },
  "Async Runner": {
    "scope": "go",
    "prefix": ["asyncrunner", "runnerasync"],
    "body": [
      "runner := async.NewRunner(",
      "\tfunc(c context.Context) error {",
      "\t\t// do something",
      "",
      "\t\treturn nil",
      "\t},",
      "\tfunc(c context.Context) error {",
      "\t\t// do something",
      "",
      "\t\treturn nil",
      "\t},",
      ")",
      "if e := runner.Run(context.Background()); e != nil {",
      "\treturn nil, e",
      "}"
    ],
    "description": "Async Runner"
  },
  "Logic List": {
    "scope": "go",
    "prefix": ["listlogic", "logiclist"],
    "body": [
      "var res []${1:ResponseStruct}",
      "order := []string{\"${0:XXXXXXX}\"}",
      "",
      "linq.From(${2:scheduleactivity.Projects}).Select(func(i interface{}) interface{} {",
      "\treturn ${1:ResponseStruct}{",
      "\t\tID:   i.(linq.KeyValue).Key.(${3:scheduleactivity.Project}),",
      "\t\tName: i.(linq.KeyValue).Value.(string),",
      "\t}",
      "}).OrderBy(func(i interface{}) interface{} {",
      "\torderIdx := linq.From(order).IndexOf(func(oi interface{}) bool {",
      "\t\treturn oi.(string) == string(i.(${1:ResponseStruct}).ID)",
      "\t})",
      "\tif orderIdx == -1 {",
      "\t\torderIdx = 9999999",
      "\t}",
      "\treturn orderIdx",
      "}).ToSlice(&res)",
      "",
      "return res, nil"
    ],
    "description": "Logic List"
  },

  // ------ Front-end ------
  "New Vue Component": {
    "scope": "vue",
    "prefix": ["vue", "vuecomp", "vuec", "comp", "compv"],
    "body": [
      "<template>",
      "\t<div>${0}</div>",
      "</template>",
      "",
      "<script lang=\"ts\">",
      "import { defineComponent } from '@vue/composition-api'",
      "",
      "export default defineComponent({",
      "\tname: 'K${1:component_name}',",
      "",
      "\tprops: {},",
      "",
      "\tdata() {",
      "\t\treturn {}",
      "\t},",
      "",
      "\tcomputed: {},",
      "",
      "\tmethods: {},",
      "",
      "\tmounted() {},",
      "",
      "\twatch: {},",
      "})",
      "</script>",
      "",
      "<style lang=\"scss\" scoped>",
      "</style>"
    ],
    "description": "Create new vue component"
  },
  "New Nuxt Page": {
    "scope": "vue",
    "prefix": ["page", "npage", "nuxtpage", "vuepage"],
    "body": [
      "<template>",
      "\t<div>${0}</div>",
      "</template>",
      "",
      "<script lang=\"ts\">",
      "import { defineComponent } from '@vue/composition-api'",
      "",
      "export default defineComponent({",
      "\tname: 'KPage${1:page_name}',",
      "",
      "\tlayout: '${2:default}',",
      "",
      "\tauth: ${3|true, false|},",
      "",
      "\tdata() {",
      "\t\treturn {}",
      "\t},",
      "",
      "\thead() {",
      "\t\treturn {",
      "\t\t\ttitle: '${4:title}',",
      "\t\t\tmeta: [",
      "\t\t\t\t{",
      "\t\t\t\t\thid: 'description',",
      "\t\t\t\t\tname: 'description',",
      "\t\t\t\t\tcontent: '${5:meta_description}',",
      "\t\t\t\t},",
      "\t\t\t],",
      "\t\t}",
      "\t},",
      "",
      "\tcomputed: {},",
      "",
      "\twatch: {},",
      "",
      "\tmounted() {},",
      "",
      "\tmethods: {},",
      "})",
      "</script>",
      "",
      "<style lang=\"scss\" scoped></style>"
    ]
  },
  "Console log value": {
    "scope": "vue,typescript,javascript",
    "prefix": ["conv", "cov"],
    "body": ["console.log('${1:var}:', ${1:var})${0}"],
    "description": "Console log value"
  },
  "Console log": {
    "scope": "vue,typescript,javascript",
    "prefix": ["conl", "col"],
    "body": ["console.log('${1}')${0}"],
    "description": "Console log"
  },
  "Create helper": {
    "scope": "javascript,typescript",
    "prefix": ["hel"],
    "body": [
      "import { Helper } from '~shared/helpers/base'",
      "",
      "export default class ${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g} extends Helper {",
      "${0}",
      "}"
    ],
    "description": "Create helper"
  },
  "Create repository": {
    "scope": "javascript,typescript",
    "prefix": ["repo"],
    "body": [
      "import { Repository } from '~shared/repositories/base'",
      "",
      "export default class ${TM_FILENAME_BASE/(.*)/${1:/pascalcase}/g} extends Repository {",
      "${0}",
      "}"
    ],
    "description": "Create repository"
  },
  "Create store/vuex": {
    "scope": "javascript,typescript",
    "prefix": ["vuex", "store"],
    "body": [
      "import { ActionTree, GetterTree, MutationTree } from 'vuex'",
      "",
      "export const state = () => ({",
      "\t// your state goes here",
      "\t${0}",
      "})",
      "",
      "export type RootState = ReturnType<typeof state>",
      "",
      "export const getters: GetterTree<RootState, RootState> = {",
      "\t// your getter goes here",
      "}",
      "",
      "export const mutations: MutationTree<RootState> = {",
      "\t// your mutation goes here",
      "}",
      "",
      "export const actions: ActionTree<RootState, RootState> = {",
      "\t// your action goes here",
      "}"
    ],
    "description": "Create repository"
  },
  "Switch Case Custom": {
    "scope": "vue,typescript,javascript",
    "prefix": ["swi", "switch", "switchcustom"],
    "body": [
      "switch (${1:key}) {",
      "\tcase ${2:value}: {",
      "\t\t${0}",
      "\t\tbreak",
      "\t}",
      "\tdefault: {",
      "\t\tbreak",
      "\t}",
      "}"
    ],
    "description": "Switch Case Custom"
  },
  "Import Model": {
    "scope": "vue,typescript,javascript",
    "prefix": ["importmodel"],
    "body": ["import { ${2:Class} } from '~shared/models/${1:file}'"],
    "description": "Import Model"
  }
}
